// RLD, v1.1, por Fábio Oikawa dos Santos, Março de 2007. 

/* O programa calcula o diagrama de bifurcação para o circuito RLD por método de Runge-Kutta de quarta ordem ou método de Gear (M=2) usando o GSL (GNU Scientific Library). Possui como varíavel de controle a amplitude ou a freqüência do gerador. Armazena os picos da tensão no diodo ou na resistência. */
/* Um arquivo chamado "input.dat" é lido do diretório atual. Nele devem estar todos os nomes dos arquivos com parâmetros. O formato do arquivo com parâmetros segue o modelo abaixo. Tudo deve ser exatamente como está: ordem, espaço, enter, igual... Apenas os valores podem ser modificados. Os dados são armazenados com o mesmo nome do arquivo de parâmetros concatenado com "_bif.dat". */
/*
Vg = 1.0
f = 150.0e3
dc = 0.0
var = AI
final = 15
n_step = 200
d = 1.0e-9
porcento = 90
itermin = 200000
itermax = 300000
peakmax = 100
Is = 4.8e-9
Tt = 5.0e-6
Cj0 = 6.0e-12
m = 0.33
n = 1.7
Vt = 0.025
Vj = 0.750
L = 0.022
R = 100.0
Vi = 0.01
Ii = 0.00001
thetai = 0.0
*/

//obs.: o diodo esta "dirigido" para o terra, então peguei a tensão no diodo com sinal trocado para o diagrama ficar "para cima".

/*
Equacoes para Oscilador Nao-linear usando Diodo
dV/dt = (I-Id)/C
dI/dt = [Vg sen(omega t) - RI - V]/L
dteta/dt = omega

Id = Is[exp(V/nVt) - 1]
C = Cj + Cd
Cj = Cj0(1 - V/Vj)^m, 1/3 <= m <= 1/2
Cd = (Tt/nVt) I = Cd0 exp(V/nVt)
*/

/*
Modelo da ON semicontuctor para spice3.

**************************************
*      Model Generated by MODPEX     *
*Copyright(c) Symmetry Design Systems*
*         All Rights Reserved        *
*    UNPUBLISHED LICENSED SOFTWARE   *
*   Contains Proprietary Information *
*      Which is The Property of      *
*     SYMMETRY OR ITS LICENSORS      *
*Commercial Use or Resale Restricted *
*   by Symmetry License Agreement    *
**************************************
* Model generated on May 30, 03
* MODEL FORMAT: SPICE3
.MODEL 1n4007 d
+IS=7.02767e-09 RS=0.0341512 N=1.80803 EG=1.05743
+XTI=5 BV=1000 IBV=5e-08 CJO=1e-11
+VJ=0.7 M=0.5 FC=0.5 TT=1e-07
+KF=0 AF=1

Fairchild
.MODEL  1N4007  D
+ IS = 3.872E-09
+ RS = 1.66E-02
+ N = 1.776
+ XTI = 3.0
+ EG = 1.110
+ CJO = 1.519E-11
+ M = 0.3554
+ VJ = 0.5928
+ FC = 0.5
+ ISR = 1.356E-09
+ NR = 2.152
+ BV = 1000.0
+ IBV = 1.0E-03

   nk/e = 0.0001530440149438464198 V/K
   T = 300 K ==> nkT/e = phi = 0.04591320448315392593 V
   Cs0 = (TT)x(IS)x(q/nkT) = Cd0 = 8.433303759968834153e-15

General Instruments
.MODEL D1N4001GP__DIODE__5 D
+ IS = 6.698e-07 RS = 0.04255 CJO = 1.949e-11 VJ = 0.3905
+TT = 4.933e-06 M = 0.3576 BV = 50+ N = 2.412 EG = 1.11 XTI = 3
+KF = 0 AF = 1 FC = 0.5 IBV = 0.005177 TNOM = 27

.model  1N4007  D(Is=14.11n N=1.984 Rs=33.89m Ikf=94.81 Xti=3 Eg=1.11
+               Cjo=25.89p M=.44 Vj=.3245 Fc=.5 Bv=1500 Ibv=10u Tt=5.7u)
*               Motorola
*               Semiconductor Databook (mid 1970s)
*               03 Jun 91       pwt     creation

*/


#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <time.h>
#include <gsl/gsl_errno.h>
#include <gsl/gsl_matrix.h>
#include <gsl/gsl_odeiv.h>

#define dim 3


/******************************** VARIÁVEIS GLOBAIS **************************************/

/************** parâmetros de entrada dos arquivos especificados em input ****************/
	/* parâmetros do gerador */
double	Vg,		//amplitude de entrada.
	f,		//freqüência de entrada.
	dc,		//offset de entrada.
	inicial,	//valor inicial do parâmetro de controle.
	final;		//valor final do parâmetro de controle.
char	var[3];		//variável de controle (freqüência = F, amplitude = A)
			//e de aquisição (tensão no diodo = V ou no resistor = I) ==> var = {AV, AI, FV ou FI}

	/* parâmetros de varredura */ 
double	d;		//dt (passo de integração).
long	itermin,	//número minimo de iterações.
	itermax,	//número máximo de iterações.
	peakmax;	//número máximo de picos adquiridos para o diagrama.
int	n_step,		//quantidade de steps.
	porcento;	//porcentagem da série para corte de transienter.

	/* parâmetros do diodo */
double	//Cd0,		//capacitância de difusão para V(diodo) ~ 0.
	Tt,		//tempo médio de trânsito.
	Cj0,		//capacitência de depleção (capacitância de junção) para V(diodo) ~ 0.
	m,		//expoente da capacitância Cd.
	n,		//coeficiente de emissão (n ~ 2). vide wikipedia.
	Vt,		//tensão térmica (kT/e ~ 26mV). vide wikipedia.
	Vj,		//tensão interna.
	Is,		//corrente de saturação.

	/* parâmetros do circuito */
	R,		//resistência.
	L,		//indutância.
	Vi,		//tensão inicial no diodo.
	Ii,		//corrente inicial na malha.
	thetai;		//(wt) - fase inicial.

/*********** fim dos parâmetros de entrada dos arquivos especificados em input ***********/

double	cutb;			//corte do transiente.
FILE	*bif,			//arquivo com os pontos para o diagrama de bifurcação.
	*media,			//arquivo para a média.
	*med_max;		//arquivo para a média dos máximos.

char	nome_arq_param[32],	//nome do arquivo com parâmetros (nome de *arq_param) extraído de *input.
	nome_bif[32],		//nome para o arquivo do diagrama de bifurcação.
	nome_med[32],		//nome para o arquivo da média da variável.
	nome_med_max[32];	//nome para o arquivo da média dos máximos.

/****************************** FIM DAS VARIÁVEIS GLOBAIS ********************************/


//#define Id(V2) (Is * (exp((V2)/(n * Vt)) - 1.0))
//#define Cd(V2) ((Tt * Is / (n * Vt)) * exp((V2) / (n*Vt)))
//#define Cj(V2) (Cj0 * ((V2 < 0.5 * Vj) ? pow((1.0 - (V2) / Vj), -m) : ((0.5 * (1 - m) + m * (V2) / Vj) / pow(0.5, (1 + m)))))
//#define C(V2) (Cd(V2) + Cj(V2))
//#define fI(I2, V2, theta2) ((Vg * sin(theta2) - R*(I2) - V2) / L)
//#define fV(I2, V2, theta2) ((I2 - Id(V2)) / C(V2))
//#define ftheta(I2, V2, theta2) (6.2831853071795862 * f)
*/
/* equações auxiliares */
/*
double Id(double Isinter, double Vinter, double nVtinter) {
	return Isinter * (exp(Vinter/nVtinter) - 1);
}

double Cd(double Ttint, double Vint, double nVtint) {
	return Ttint * exp(Vint/nVtint);
}


double Cj(double Cj0int, double Vint, double Vjint) {
	return Cj0int / sqrt(1.0 - Vint/Vjint);
}

double C(double Ttint, double Cj0int, double Vint, double nVtint, double Vjint) {
	return Cd(Ttint, Vint, nVtint) + Cj(Cj0int, Vint, Vjint);
}
*/
/* fim das equações auxiliares */


/* funcoes das equacoes diferenciais  */
/*
double fI(double Iint, double Vint, double thetaint) {
	return (Vg * sin(thetaint) - R*Iint - Vint)/L;
}

double fV(double Iint, double Vint, double thetaint) {
	return (Iint - Id(Is, Vint, n*Vt)) / C(Tt, Cj0, Vint, n*Vt, Vj);
}

double ftheta() {
	return 6.2831853071795862 * f;
}
*/
/* fim das funcoes das equacoes diferenciais  */

int func (double t, const double y[], double f[],
	void *params)
{
	f[0] = (Vg * sin(6.2831853071795862 * freq * t) - R * (y[0]) - y[1]) / L;
	f[1] = (y[0] - (Is) * (exp((y[1])/(n*Vt)) - 1.0)) / (Cj0 * ((y[1] < 0.5 * Vj) ? pow((1.0 - (y[1]) / Vj), -m) : ((0.5 * (1 - m) + m * (y[1]) / Vj) / pow(0.5, (1 + m)))) + (Cd0) * exp((y[1])/(n*Vt)));

	return GSL_SUCCESS;
}

/**************** procedimentos de cálculo runge-kutta 4ª ordem ******************/

void rk4AI() {	//controle de amplitude, aquisição de corrente
	//declaração de variáveis.
	const gsl_odeiv_step_type * T 
		= gsl_odeiv_step_rk4;

	gsl_odeiv_step * s 
		= gsl_odeiv_step_alloc (T, dim);
	gsl_odeiv_control * c 
		= gsl_odeiv_control_y_new (1e-10, 0.0);
	gsl_odeiv_evolve * e 
		= gsl_odeiv_evolve_alloc (dim);

	gsl_odeiv_system sys = {func, jac, dim};

	double t = 0.0, t1 = 1e-2;
	double h = 1e-7;
	double y[dim] = { 0.0, 0.0 };

	long	cont,						//incrementa os passos de integração.
		num_peak,					//número de picos.
		num_med_max;					//número de picos para a média dos máximos.

		/* variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
	double	k1[dim],
		k2[dim],
		k3[dim],
		k4[dim],
		/* fim das variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
		
		I = Ii,						//inicialização da corrente na malha.
		V = Vi,						//inicialização da tensão no diodo.
		theta = thetai,					//inicialização da variável theta = omega * t.

		Ia = 0.0,					//valor anterior ao atual.
		Iaa,						//valor anterior ao anterior.
		step = (final - inicial) / (n_step - 1),	//tamanho de cada passo.
		t,						//inicialização do tempo.
		soma,						//soma da corrente.
		soma_max;					//soma dos máximos da corrente.
		

	//fim de declaração de variáveis.

	printf("\n Iniciando o calculo.\n");
	fprintf(bif, "# Versão do programa: 4.1\n");
	fprintf(bif, "# Vg inicial = %.15lf\n# Vg final = %.15lf\n", inicial, final);

	for (Vg = inicial; Vg <= final; Vg += step) {
		num_peak = 0l;
		num_med_max = 0l;
		t = 0.0;
		soma = 0.0;
		soma_max = 0.0;
		Ia = 0.0;

		while (t < t1) {
			int status = gsl_odeiv_evolve_apply (e, c, s,
							&sys,
							&t, t1,
							&h, y);
	
			if (status != GSL_SUCCESS)
				break;

			Iaa = Ia;
			Ia = y[1];
			soma += y[1];
 			if ((Ia > y[1]) && (Ia > Iaa)) {
				  soma_max += Ia; 
				  num_med_max++;
			}//end if

			/* corta o transiente e localiza um máximo  da corrente */
			if ((cont > cutb) && (Ia > I) && (Ia > Iaa) && (num_peak < peakmax)) {
				  fprintf(bif, "%.15lf %.15lf\n", Vg, R * Ia); 
				  num_peak++;
			}//end if
			fprintf (arq, "%.5e %.5e %.5e\n", t, y[0], y[1]);
			fflush(arq);
		}

		gsl_odeiv_evolve_free (e);
		gsl_odeiv_control_free (c);
		gsl_odeiv_step_free (s);

// 		for (cont = 0l; cont <= itermax; cont++) {
// 			/* as linhas abaixo constituem o algoritmo de Runge-Kutta de quarta ordem */
// 			k1[0] = d * fI(I, V, theta);
// 			k1[1] = d * fV(I, V, theta);
// 			k1[2] = d * ftheta(I, V, theta);
// 
// 			k2[0] = d * fI(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
// 			k2[1] = d * fV(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
// 			k2[2] = d * ftheta(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
// 
// 			k3[0] = d * fI(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
// 			k3[1] = d * fV(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
// 			k3[2] = d * ftheta(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
// 
// 			k4[0] = d * fI(I+k3[0], V+k3[1], theta+k3[2]);
// 			k4[1] = d * fV(I+k3[0], V+k3[1], theta+k3[2]);
// 			k4[2] = d * ftheta(I+k3[0], V+k3[1], theta+k3[2]);
// 
// 			Iaa = Ia;
// 			Ia = I;
// 
// 			I += (k1[0]+2.0*k2[0]+2.0*k3[0]+k4[0])/6.0;
// 			V += (k1[1]+2.0*k2[1]+2.0*k3[1]+k4[1])/6.0;
// 			theta += (k1[2]+2.0*k2[2]+2.0*k3[2]+k4[2])/6.0;
// 
// 			t += d;
// 
// 			soma += I;
//  			if ((Ia > I) && (Ia > Iaa)) {
// 				  soma_max += Ia; 
// 				  num_med_max++;
// 			}//end if
// 
// 			/* corta o transiente e localiza um máximo  da corrente */
// 			if ((cont > cutb) && (Ia > I) && (Ia > Iaa) && (num_peak < peakmax)) {
// 				  fprintf(bif, "%.15lf %.15lf\n", Vg, R * Ia); 
// 				  num_peak++;
// 			}//end if
// 		}//end for
		fflush(bif);
		fprintf(media, "%.15lf %.15lf\n", Vg, soma/(itermax + 1));
		fprintf(med_max, "%.15lf %.15lf\n", Vg, (num_med_max ? soma_max/num_med_max : 0.0));
	}//end for
}

void rk4AV() {	//controle de amplitude, aquisição de tensão
	//declaração de variáveis.
	long	cont,						//incrementa os passos de integração.
		num_peak,					//número de picos.
		num_med_max;					//número de picos para a média dos máximos.

		/* variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
	double	k1[dim],
		k2[dim],
		k3[dim],
		k4[dim],
		/* fim das variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
		
		I = Ii,						//inicialização da corrente na malha.
		V = Vi,						//inicialização da tensão no diodo.
		theta = thetai,					//inicialização da variável theta = omega * t.

		Va = 0.0,					//valor anterior ao atual.
		Vaa,						//valor anterior ao anterior.
		step = (final - inicial) / (n_step - 1),	//tamanho de cada passo.
		t,						//inicialização do tempo.
		soma,						//soma da tensão.
		soma_max;					//soma dos máximos da tensão.
		

	//fim de declaração de variáveis.

	printf("\n Iniciando o calculo.\n");
	fprintf(bif, "# Versão do programa: 4.1\n");
	fprintf(bif, "# Vg inicial = %.15lf\n# Vg final = %.15lf\n", inicial, final);

	for (Vg = inicial; Vg <= final; Vg += step) {
		num_peak = 0l;
		num_med_max = 0l;
		t = 0.0;
		soma = 0.0;
		soma_max = 0.0;
		for (cont = 0l; cont <= itermax; cont++) {
			/* as linhas abaixo constituem o algoritmo de Runge-Kutta de quarta ordem */
			k1[0] = d * fI(I, V, theta);
			k1[1] = d * fV(I, V, theta);
			k1[2] = d * ftheta(I, V, theta);

			k2[0] = d * fI(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[1] = d * fV(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[2] = d * ftheta(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);

			k3[0] = d * fI(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[1] = d * fV(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[2] = d * ftheta(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );

			k4[0] = d * fI(I+k3[0], V+k3[1], theta+k3[2]);
			k4[1] = d * fV(I+k3[0], V+k3[1], theta+k3[2]);
			k4[2] = d * ftheta(I+k3[0], V+k3[1], theta+k3[2]);

			Vaa = Va;
			Va = V;

			I += (k1[0]+2.0*k2[0]+2.0*k3[0]+k4[0])/6.0;
			V += (k1[1]+2.0*k2[1]+2.0*k3[1]+k4[1])/6.0;
			theta += (k1[2]+2.0*k2[2]+2.0*k3[2]+k4[2])/6.0;

			t += d;

			soma += V;
 			if ((Va < V) && (Va < Vaa)) {
				  soma_max -= Va; 
				  num_med_max++;
			}//end if

			/* corta o transiente e localiza um mínimo da tensão */
			if ((cont > cutb) && (Va < V) && (Va < Vaa) && (num_peak < peakmax)) {
				  fprintf(bif, "%.15lf %.15lf\n", Vg, -Va); 
				  num_peak++;
			}//end if
		}//end for
		fflush(bif);
		fprintf(media, "%.15lf %.15lf\n", Vg, soma/(itermax + 1));
		fprintf(med_max, "%.15lf %.15lf\n", Vg, (num_med_max ? soma_max/num_med_max : 0.0));
	}//end for
}//end rk4AV

void rk4FI() {	//controle de freqüência, aquisição de corrente
	//declaração de variáveis.
	long	cont,						//incrementa os passos de integração.
		num_peak,					//número de picos.
		num_med_max;					//número de picos para a média dos máximos.

		/* variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
	double	k1[dim],
		k2[dim],
		k3[dim],
		k4[dim],
		/* fim das variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
		
		I = Ii,						//inicialização da corrente na malha.
		V = Vi,						//inicialização da tensão no diodo.
		theta = thetai,					//inicialização da variável theta = omega * t.

		Ia = 0.0,					//valor anterior ao atual.
		Iaa,						//valor anterior ao anterior.
		step = (final - inicial) / (n_step - 1),	//tamanho de cada passo.
		t,						//inicialização do tempo.
		soma,						//soma da corrente.
		soma_max;					//soma dos máximos da corrente.
		

	//fim de declaração de variáveis.

	printf("\n Iniciando o calculo.\n");
	fprintf(bif, "# Versão do programa: 4.1\n");
	fprintf(bif, "# f inicial = %.15lf\n# f final = %.15lf\n", inicial, final);

	for (f = inicial; f <= final; f += step) {
		num_peak = 0l;
		num_med_max = 0l;
		t = 0.0;
		soma = 0.0;
		soma_max = 0.0;
		for (cont = 0l; cont <= itermax; cont++) {
			/* as linhas abaixo constituem o algoritmo de Runge-Kutta de quarta ordem */
			k1[0] = d * fI(I, V, theta);
			k1[1] = d * fV(I, V, theta);
			k1[2] = d * ftheta(I, V, theta);

			k2[0] = d * fI(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[1] = d * fV(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[2] = d * ftheta(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);

			k3[0] = d * fI(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[1] = d * fV(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[2] = d * ftheta(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );

			k4[0] = d * fI(I+k3[0], V+k3[1], theta+k3[2]);
			k4[1] = d * fV(I+k3[0], V+k3[1], theta+k3[2]);
			k4[2] = d * ftheta(I+k3[0], V+k3[1], theta+k3[2]);

			Iaa = Ia;
			Ia = I;

			I += (k1[0]+2.0*k2[0]+2.0*k3[0]+k4[0])/6.0;
			V += (k1[1]+2.0*k2[1]+2.0*k3[1]+k4[1])/6.0;
			theta += (k1[2]+2.0*k2[2]+2.0*k3[2]+k4[2])/6.0;

			t += d;

			soma += I;
 			if ((Ia > I) && (Ia > Iaa)) {
				  soma_max += Ia; 
				  num_med_max++;
			}//end if

			/* corta o transiente e localiza um máximo  da corrente */
			if ((cont > cutb) && (Ia > I) && (Ia > Iaa) && (num_peak < peakmax)) {
				  fprintf(bif, "%.15lf %.15lf\n", f, R * Ia); 
				  num_peak++;
			}//end if
		}//end for
		fflush(bif);
		fprintf(media, "%.15lf %.15lf\n", f, soma/(itermax + 1));
		fprintf(med_max, "%.15lf %.15lf\n", f, (num_med_max ? soma_max/num_med_max : 0.0));
	}//end for
}//end rk4FI

void rk4FV() {	//controle de freqüência, aquisição de tensão
	//declaração de variáveis.
	long	cont,						//incrementa os passos de integração.
		num_peak,					//número de picos.
		num_med_max;					//número de picos para a média dos máximos.

		/* variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
	double	k1[dim],
		k2[dim],
		k3[dim],
		k4[dim],
		/* fim das variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
		
		I = Ii,						//inicialização da corrente na malha.
		V = Vi,						//inicialização da tensão no diodo.
		theta = thetai,					//inicialização da variável theta = omega * t.

		Va = 0.0,					//valor anterior ao atual.
		Vaa,						//valor anterior ao anterior.
		step = (final - inicial) / (n_step - 1),	//tamanho de cada passo.
		t,						//inicialização do tempo.
		soma,						//soma da tensão.
		soma_max;					//soma dos máximos da tensão.
		

	//fim de declaração de variáveis.

	printf("\n Iniciando o calculo.\n");
	fprintf(bif, "# Versão do programa: 4.1\n");
	fprintf(bif, "# f inicial = %.15lf\n# f final = %.15lf\n", inicial, final);

	for (f = inicial; f <= final; f += step) {
		num_peak = 0l;
		num_med_max = 0l;
		t = 0.0;
		soma = 0.0;
		soma_max = 0.0;
		for (cont = 0l; cont <= itermax; cont++) {
			/* as linhas abaixo constituem o algoritmo de Runge-Kutta de quarta ordem */
			k1[0] = d * fI(I, V, theta);
			k1[1] = d * fV(I, V, theta);
			k1[2] = d * ftheta(I, V, theta);

			k2[0] = d * fI(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[1] = d * fV(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[2] = d * ftheta(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);

			k3[0] = d * fI(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[1] = d * fV(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[2] = d * ftheta(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );

			k4[0] = d * fI(I+k3[0], V+k3[1], theta+k3[2]);
			k4[1] = d * fV(I+k3[0], V+k3[1], theta+k3[2]);
			k4[2] = d * ftheta(I+k3[0], V+k3[1], theta+k3[2]);

			Vaa = Va;
			Va = V;

			I += (k1[0]+2.0*k2[0]+2.0*k3[0]+k4[0])/6.0;
			V += (k1[1]+2.0*k2[1]+2.0*k3[1]+k4[1])/6.0;
			theta += (k1[2]+2.0*k2[2]+2.0*k3[2]+k4[2])/6.0;

			t += d;

			soma += V;
 			if ((Va < V) && (Va < Vaa)) {
				  soma_max -= Va; 
				  num_med_max++;
			}//end if

			/* corta o transiente e localiza um mínimo da tensão */
			if ((cont > cutb) && (Va < V) && (Va < Vaa) && (num_peak < peakmax)) {
				  fprintf(bif, "%.15lf %.15lf\n", f, -Va); 
				  num_peak++;
			}//end if
		}//end for
		fflush(bif);
		fprintf(media, "%.15lf %.15lf\n", f, soma/(itermax + 1));
		fprintf(med_max, "%.15lf %.15lf\n", f, (num_med_max ? soma_max/num_med_max : 0.0));
	}//end for
}//end rk4FV

void rk4CH() { //controle de freqüência, aquisição de tensão. ida e volta na freqüência (ciclo de histerese).
	//declaração de variáveis.
	long	cont,						//incrementa os passos de integração.
		num_peak;					//número de picos.

		/* variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
	double	k1[dim],
		k2[dim],
		k3[dim],
		k4[dim],
		/* fim das variáveis auxiliares para cálculo de runge-kutta 4ª ordem */
	
		I = Ii,						//inicialização da corrente na malha.
		V = Vi,						//inicialização da tensão no diodo.
		theta = thetai,					//inicialização da variável theta = omega * t.
	
		Va = 0.0,					//valor anterior ao atual.
		Vaa,						//valor anterior ao anterior.
		step = (final - inicial) / (n_step - 1),	//tamanho de cada passo.
		t;						//inicialização do tempo.

	//fim de declaração de variáveis.

/* cálculo da ida */ 
	printf("\n Iniciando o calculo \n");
	fprintf(bif, "# f inicial = %.15lf\n# f final = %.15lf\n", inicial, final);

	for (f = inicial; f <= final; f += step) {

		num_peak = 0l;
		t = 0.0;

		for (cont = 0l; cont <= itermax; cont++) {
			/* as linhas abaixo constituem o algoritmo de Runge-Kutta de quarta ordem */
			k1[0] = d * fI(I, V, theta);
			k1[1] = d * fV(I, V, theta);
			k1[2] = d * ftheta(I, V, theta);

			k2[0] = d * fI(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[1] = d * fV(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[2] = d * ftheta(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			
			k3[0] = d * fI(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[1] = d * fV(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[2] = d * ftheta(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );

			k4[0] = d * fI(I+k3[0], V+k3[1], theta+k3[2]);
			k4[1] = d * fV(I+k3[0], V+k3[1], theta+k3[2]);
			k4[2] = d * ftheta(I+k3[0], V+k3[1], theta+k3[2]);
		
			Vaa = Va;
			Va = V;

			I += (k1[0]+2.0*k2[0]+2.0*k3[0]+k4[0])/6.0;
			V += (k1[1]+2.0*k2[1]+2.0*k3[1]+k4[1])/6.0;
			theta += (k1[2]+2.0*k2[2]+2.0*k3[2]+k4[2])/6.0;

			t += d;

			/* corta o transiente e localiza um maximo  da corrente */
			if ((cont > cutb) && (Va < V) && (Va < Vaa) && (num_peak < peakmax)) {
				fprintf(bif, "%.15lf %.15lf\n", f, -Va); 
				num_peak++;
			} //end if

			if (num_peak > peakmax) break;
		}//end for
		fflush(bif);
	}//end for

/* fim do cálculo da ida */ 
	fclose(bif);
	strcpy(nome_bif, nome_arq_param);
	strcat(nome_bif, "_volta.dat");
	if ((bif = fopen(nome_bif, "w")) == NULL) {
		printf(" O arquivo não pode ser aberto\n");
		return;
	}//end if

/* cálculo da volta */
	I = Ii;			//inicialização da corrente na malha.
	V = Vi;			//inicialização da tensão no diodo.
	theta = thetai;		//inicialização da variável theta = omega * t.
	Va = 0.0;		//valor anterior ao atual.

	for (f = final; f >= inicial; f -= step) {

		num_peak = 0l;
		t = 0.0;

		for (cont = 0l; cont <= itermax; cont++) {
			/* as linhas abaixo constituem o algoritmo de Runge-Kutta de quarta ordem */
			k1[0] = d * fI(I, V, theta);
			k1[1] = d * fV(I, V, theta);
			k1[2] = d * ftheta(I, V, theta);

			k2[0] = d * fI(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[1] = d * fV(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			k2[2] = d * ftheta(I+k1[0]*0.5, V+k1[1]*0.5, theta+k1[2]*0.5);
			
			k3[0] = d * fI(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[1] = d * fV(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );
			k3[2] = d * ftheta(I+k2[0]*0.5, V+k2[1]*0.5, theta+k2[2]*0.5 );

			k4[0] = d * fI(I+k3[0], V+k3[1], theta+k3[2]);
			k4[1] = d * fV(I+k3[0], V+k3[1], theta+k3[2]);
			k4[2] = d * ftheta(I+k3[0], V+k3[1], theta+k3[2]);
		
			Vaa = Va;
			Va = V;

			I += (k1[0]+2.0*k2[0]+2.0*k3[0]+k4[0])/6.0;
			V += (k1[1]+2.0*k2[1]+2.0*k3[1]+k4[1])/6.0;
			theta += (k1[2]+2.0*k2[2]+2.0*k3[2]+k4[2])/6.0;

			t += d;

			/* corta o transiente e localiza um minimo da tensão */
			if ((cont > cutb) && (Va < V) && (Va < Vaa) && (num_peak < peakmax)) {
				fprintf(bif, "%.15lf %.15lf\n", f, -Va); 
				num_peak++;
			} //end if

			if (num_peak > peakmax) break;
		}//end for
		fflush(bif);
	}//end for
/* fim do cálculo da volta */
}//end rk4CH

/************* fim dos procedimentos de cálculo runge-kutta 4ª ordem *************/

int main (void)
{
	const gsl_odeiv_step_type * T 
		= gsl_odeiv_step_rk4;

	gsl_odeiv_step * s 
		= gsl_odeiv_step_alloc (T, dim);
	gsl_odeiv_control * c 
		= gsl_odeiv_control_y_new (1e-10, 0.0);
	gsl_odeiv_evolve * e 
		= gsl_odeiv_evolve_alloc (dim);

//	double mu = 10;
	gsl_odeiv_system sys = {func, jac, dim};

	double t = 0.0, t1 = 1e-2;
	double h = 1e-7;
	double y[dim] = { 0.0, 0.0 };

	FILE *arq;
	time_t tempo0, tempo1;

	arq = fopen("edo3-gear.dat", "w");

	tempo0 = time(NULL);

	while (t < t1)
	{
		int status = gsl_odeiv_evolve_apply (e, c, s,
						&sys,
						&t, t1,
						&h, y);

		if (status != GSL_SUCCESS)
			break;
	
		fprintf (arq, "%.5e %.5e %.5e\n", t, y[0], y[1]);
		fflush(arq);
	}

	tempo1 = time(NULL);
	printf(" intervalo de tempo: %f\n", difftime(tempo1, tempo0));
	gsl_odeiv_evolve_free (e);
	gsl_odeiv_control_free (c);
	gsl_odeiv_step_free (s);
	fclose(arq);
	return 0;
}

int main(void) {

	const gsl_odeiv_step_type * T 
		= gsl_odeiv_step_rk4;

	gsl_odeiv_step * s 
		= gsl_odeiv_step_alloc (T, dim);
	gsl_odeiv_control * c 
		= gsl_odeiv_control_y_new (1e-10, 0.0);
	gsl_odeiv_evolve * e 
		= gsl_odeiv_evolve_alloc (dim);

	gsl_odeiv_system sys = {func, jac, dim};

	double t = 0.0, t1 = 1e-2;
	double h = 1e-7;
	double y[dim] = { 0.0, 0.0 };

	FILE	*input,			//entrada contendo todos os nomes dos arquivos com parâmetros.
		*arq_param;		//arquivo com os parâmetros.

	time_t	tempo1, tempo0;		//tempo de cálculo = time1 - time0

	/* output to screen */
	printf(" PROGRAMA RLD.\n" ) ;
	printf(" (Versão 4.1 - Março de 2007 - por Fábio Oikawa dos Santos)\n" ) ;

	if ((input = fopen("input.dat", "r")) == NULL) {
		printf(" O arquivo não pode ser aberto\n");
		exit(1);
	}//end if

	while(!feof(input)) {

		fscanf(input, "%s", nome_arq_param);

		if ((arq_param = fopen(nome_arq_param, "r")) == NULL) {
			printf(" O arquivo não pode ser aberto\n");
			break;
		}//end if

		/* parameters initialization from file */
		fscanf(arq_param, "Vg = %lf\nf = %lf\ndc = %lf\n", &Vg, &f, &dc);
		fscanf(arq_param, "var = %s\nfinal = %lf\nn_step = %d\n", var, &final, &n_step);
		fscanf(arq_param, "d = %lf\nporcento = %d\n", &d, &porcento);
		fscanf(arq_param, "itermin = %ld\nitermax = %ld\npeakmax = %ld\n", &itermin, &itermax, &peakmax);
		fscanf(arq_param, "Is = %lf\nTt = %lf\nCj0 = %lf\n", &Is, &Tt, &Cj0);
		fscanf(arq_param, "m = %lf\nn = %lf\nVt = %lf\nVj = %lf\n", &m, &n, &Vt, &Vj);
		fscanf(arq_param, "L = %lf\nR = %lf\n", &L, &R);
		fscanf(arq_param, "Vi = %lf\nIi = %lf\nthetai = %lf", &Vi, &Ii, &thetai);

		cutb = porcento * itermin / 100;

		if (strcmp(var, "CH")) {
			strcpy(nome_bif, nome_arq_param);
			strcat(nome_bif, "_bif.dat");
			printf("\n Arquivo: %s\n", nome_bif);
		}//end if
		else {
			strcpy(nome_bif, nome_arq_param);
			strcat(nome_bif, "_ida.dat");
		}//end else

		if ((bif = fopen(nome_bif, "w")) == NULL) {
			printf(" O arquivo não pode ser aberto\n");
			break;
		}//end if
	
		if (strcmp(var, "CH")) {
			strcpy(nome_med, nome_arq_param);
			strcat(nome_med, "_med.dat");
			if ((media = fopen(nome_med, "w")) == NULL) {
				printf(" O arquivo não pode ser aberto\n");
				break;
			}//end if

			strcpy(nome_med_max, nome_arq_param);
			strcat(nome_med_max, "_med_max.dat");
			if ((med_max = fopen(nome_med_max, "w")) == NULL) {
				printf(" O arquivo não pode ser aberto\n");
				break;
			}//end if
		}//end if

		tempo0 = time(NULL);	//contagem de tempo iniciada.

		if (!strcmp(var, "AI")) {
			inicial = Vg;
			rk4AI();	//rotina principal de cálculo (controle de amplitude, aquisição de corrente).
		}
		else if  (!strcmp(var, "AV")) {
			inicial = Vg;
			rk4AV();	//rotina principal de cálculo (controle de amplitude, aquisição de tensão).
		}
		else if (!strcmp(var, "FI")) {
			inicial = f;
			rk4FI();	//rotina principal de cálculo (controle de freqüência, aquisição de corrente).
		}
		else if (!strcmp(var, "FV")) {
			inicial = f;
			rk4FV();	//rotina principal de cálculo (controle de freqüência, aquisição de tensão).
		}
		else if (!strcmp(var, "CH")) {
			inicial = f;
			rk4CH();	//rotina principal de cálculo (controle de freqüência, aquisição de tensão).
		}
		else printf(" %s: opção inválida\n", var);

		fclose(bif);
		fclose(media);
		fclose(med_max);
		fclose(arq_param);
		
		tempo1 = time(NULL);	//contagem de tempo finalizada.
		printf(" Arquivo %s pronto em %f segundos\n", nome_bif, difftime(tempo1, tempo0));
		printf(" Arquivo %s pronto em %f segundos\n", nome_med, difftime(tempo1, tempo0));
		printf(" Arquivo %s pronto em %f segundos\n", nome_med_max, difftime(tempo1, tempo0));

	}//end while
	
	fclose(input);	 
	printf(" All files calculated.\n");
	return 0;
}//----------------------------------End Main---------------------------------


